% TODO: ПОМЕНЯЙТЕ НА СВОЙ ПУТЬ ПРИ СБОРКЕ
\renewcommand{\mainFolder}{/home/aleksei/github_projects/latex_works/informatics/3sem}
\renewcommand{\myFolder}{\mainFolder/lecture_\arabic{lectureNo}/}

%	LECTURE INFO
%----------------------------------------------------------------------------------------
\renewcommand{\lectureSubject}{Виртуальные методы}
%----------------------------------------------------------------------------------------
%
% Главное - указывать в путях для добавляемых файлов переменную \myFolder.
% Так, новый cpp файл должен иметь путь \cppfile{\myFolder/main}{....} (указывается без расширения)
% Нельзя писать \cppfile{main}{...} !!!
% Если не выполнить это требование, большой проект не будет собираться



\begin{lecture}[\lectureSubject]
	\begin{lecSection}[Вызовы методов при работе с классами-наследниками]
		Простейшие классы -- структуры. Напишем на них пример:
		\cppfile{\myFolder/1}{Пример виртуальных функций}{1}
		Заметьте, что у структур наследование всегда публичное.
		
		\begin{lecSubsection}{Распределение памяти}
			Экземпляр класса A будет занимать память, соответствующую размеру одного \textbf{char}'а, B -- уже одного \textbf{char} и одного \textbf{int} (для шарящих: пока пренебрежем выравниванием), С -- \textbf{int} и \textbf{double}. При этом занимаемые размеры расположатся в таком порядке: $ a < b < c $.
		\end{lecSubsection}
	
		\begin{lecSection}[Виртуальные методы]
			Рассмотрим пример:
			\cppfile{\myFolder/2}{Вызов наследника вместо родителя}{2}
			Какая функция будет вызвана в \textbf{foo()}? Ответ прост: всегда из класса \textbf{A}. Дело в том, что функция \textbf{foo} \textit{компилируема}: при сборке проекта \textbf{p} будет 'увиден' компилятором как экземпляр класса \textbf{A} и вызов \textbf{p.bar()} будет привязан к области памяти \textbf{A}.
			
			Как бороться с этим? Есть несколько способов:
			\begin{enumerate}
				\item Поле типа (\underline{не рекомендуется}). Добавим специальный атрибут \textbf{int m\_type} в базовый класс. В конструкторах производных классов заполним \textbf{m\_type} своими ID типа (например, у \textbf{A} будет 0, у \textbf{B} будет 1). При этом будет происходить \textit{коммутация} вызовов:
				
				\textbf{p.bar()} превратится вот в такое:
				\cppfile{\myFolder/3}{Условия на поле типа}{3}
				Это кошмар. Нам надо знать все классы, которые наследуют базовый, да и к тому же вести их учет через ID. Есть альтернатива.
				\item Сохраним указатель на функцию в классе. Она уйдет всем наследникам. В конструкторе каждого наследника мы будем переопределять ссылку на этот метод, вот так:
				\cppfile{\myFolder/4}{Переопределение указателя на функцию}{4}
				Остаются проблемы. Вдруг дочерний класс будет использовать родительский метод? Вдруг таких методов будет много? Приведем еще один способ.
				
				\item \label{v3} Можно хранить не одну ссылку на метод, а указатель на таблицы, содержащей указатели на нужные методы. Те же костыли, те же проблемы. Запутаться еще легче, ведь для каждого класса эта таблица будет своя.
			\end{enumerate}
			
			Но есть и  хороший способ. Все это уже встроено в язык. Все обрабатывается \underline{автоматически}. Для этого нужно только одно -- указать перед методом слово \textbf{virtual}. Для всех потомков будет создана таблица виртуальных методов (подобно той, что указана в п.\ref{v3} выше), которая будет автоматически заполняться у потомков.
			
			Итак, \textit{виртуальные} методы -- те методы, которые предполагаются быть переопределенными в дочерних классах.
		\end{lecSection}
		
		\begin{lecSection}[Множественное наследование]
			\begin{lecSubsection}{Абстрактный класс}
				Класс, у которого есть хотя бы один абстрактный метод с нулевой реализацией, является \textbf{абстрактным}. Его экземпляры нельзя создавать, но при этом абстрактные классы обладают мощной штукой -- множественное наследование.
				\cppfile{\myFolder/5}{Абстрактный метод с нулевой реализацией}{5}
			\end{lecSubsection}
			\begin{lecSubsection}{Множественное наследование}
				Множественное наследование --- это явление, когда один класс наследует несколько других. При этом класс, как это говорят, будет удовлетворять нескольким \textit{интерфейсам}. У такой штуки есть масса проблем. Что, если оба класса имеют два одинаковых метода с одинаковой сигнатурой? А атрибуты? С ними могут возникнуть большие проблемы при пересечении. Но если все методы виртуальны, а атрибутов нет, то все славно: даже если классы содержат пересекающиеся методы, мы сможем выбрать для переопределения любой из них (компилятору будет все равно, ведь они все равно не содержат реализации). Именно поэтому рекомендуется делать множественное наследование \underline{только} в абстрактных классах и наследовать при этом \underline{только} абстрактные классы.
			\end{lecSubsection}
			
			\begin{lecSubsection}{Применение абстрактных классов}
				Итак, в чем польза абстрактных методов и классов? Они позволяют грамотнее и логичнее организовывать структуру кода, объединяя схожие классы. Наглядный пример их использования мы видели в лабе 12 'Арифметические драконы', когда реализовывали класс \textbf{Dragon}, а впоследствии и класс \textbf{Enemy} -- каждый из них не обозначал какой-либо реальный объект сам по себе, однако служил шаблоном для клепания других классов, уже вполне связанных с реальными объектами (например, \textbf{Dragon} служил образом для класса \textbf{GreenDragon}).
			\end{lecSubsection}
		\end{lecSection}
	\end{lecSection}
\end{lecture}
\stepcounter{lectureNo}