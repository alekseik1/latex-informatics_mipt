% TODO: ПОМЕНЯЙТЕ НА СВОЙ ПУТЬ ПРИ СБОРКЕ
\renewcommand{\mainFolder}{/home/aleksei/github_projects/latex_works/informatics/3sem}
\renewcommand{\myFolder}{\mainFolder/lecture_\arabic{lectureNo}/}

%	LECTURE INFO
%----------------------------------------------------------------------------------------
\renewcommand{\lectureSubject}{Объектно-ориентированное программирование}
%----------------------------------------------------------------------------------------
%
% Главное - указывать в путях для добавляемых файлов переменную \myFolder.
% Так, новый cpp файл должен иметь путь \cppfile{\myFolder/main}{....} (указывается без расширения)
% Нельзя писать \cppfile{main}{...} !!!
% Если не выполнить это требование, большой проект не будет собираться



\begin{lecture}[\lectureSubject]
	\begin{lecSection}[Класс]
		Класс --- это пользовательский тип, который объединяет данные и код, их обрабатывающий.
		
		Раньше мы `клали` данные структуры в объект \textbf{struct}, а рядом дописывали функции для нее. Теперь же мы хотим, чтобы с нашей структурой можно было работать \textbf{только} через функции, объявленные внутри нее. Этот принцип носит название \textit{принципа сокрытия данных}, а такая организация кода -- \textit{инкапсуляция}.
		\end{lecSection}
		
		\begin{lecSection}[Пример класса]
		Самый простой способ сделать подобие класса -- это использовать \textbf{struct}. Построим структуру \underline{Студент}, имеющую вид:
		\begin{enumerate}
			\item Поле \textbf{age} -- возраст студента
			\item Поле \textbf{name} -- имя
			\item Остальные методы, а именно:
			\begin{enumerate}
				\item \textbf{init} -- создание экземпляра
				\item \textbf{aging} -- увеличение возраста на 1
				\item \textbf{print} -- печать информации о студенте.
			\end{enumerate}
		\end{enumerate}
		
		\newpage
		\cppfile{\myFolder/1}{\textbf{struct} как пример класса}{1}
		В коде выше есть некоторые особенности:
		\begin{enumerate}
			\item Строка \underline{20} --- \textbf{const} после объявления функции означает, что внутри функции мы не можем менять сам объект класса.
			\item Строка \underline{31} -- не будет работать, так как "Vasya" есть \textbf{char[]*}, а метод класса требует \textbf{std::string}.
			\item Строка \underline{34} -- опасная операция (побитовое копирование может вести себя непредсказуемо, прим. ТФ).
			\item Мы можем изменять снаружи переменные \textit{внутри} объекта, то есть, имеет силу код \textbf{a.age += 10}. Это плохо, и дальше мы рассмотрим, как такую проблему решить.
		\end{enumerate}
	\end{lecSection}
	
	\begin{lecSection}[Конструкторы и деструкторы]
		\begin{lecSubsection}{Конструктор}
		Когда мы создавали объект `студент` в коде выше, нам каждый раз надо было инициализировать его через функцию \textbf{init()}. Однако мы можем это забыть сделать.
		
		Для защиты от этого существуют \underline{конструкторы} класса: особые методы, вызываемые при создании экземпляра класса. Перепишем код:
		\cppfile{\myFolder/2}{Наш класс с конструктором}{2}
		Конструктор ничего не возвращает. Помимо этого, объект класса \textbf{не} считается созданным до тех пор, пока не будет выполнен его конструктор.
		\end{lecSubsection}
		
		\begin{lecSubsection}{Деструктор}
		По аналогии с конструктором существует \textit{деструктор}.
		
		Деструктор --- особый метод, который ничего не возвращает и вызывается при удалении объекта.
		\end{lecSubsection}
		\begin{lecSubsection}{Конструктор по умолчанию}
			Если мы не создадим конструктор, то компилятор это сделает за нас, создав \textit{конструктор по умолчанию}. То же самое с деструктором.
			
			Однако, если мы создадим свой конструктор, то экземпляры класса уже надо будет клепать по его правилам, то есть, нам надо будет передавать объекту при создании те аргументы, которые принимает конструктор (в нашем случае \textbf{age} и \textbf{name}).
			\cppfile{\myFolder/3}{Особенности работы конструктора}{3}
			В примере выше на строке \underline{4} требуется вызов конструктора по умолчанию (при создании массива), а его нет -- поэтому она и помечена как неработающая. То же самое справедливо для строки \underline{1}.
			\newpage
		\end{lecSubsection}
		\begin{lecSection}[Примеры работы конструктора и деструктора]
			\cppfile{\myFolder/4}{Пример вызова деструктора}{4}
			В коде выше на строке \underline{12} мы делаем запись о том, что объект создан. На строке \underline{26} объявлен дестуктор -- код внутри будет выполнен, когда объект перестанет существовать.
			
			Код \ref{4} компилируется: попробуйте его запустить на своей машине и увидите, как работает деструктор.
		\end{lecSection}
		\begin{lecSection}[Пример. Структура Stack]
			\cppfile{\myFolder/5}{Структура Stack}{5}
			Обратите внимание на конструктор (строка \underline{7}) -- он может использоваться и как конструктор по-умолчанию (если не передавать ему параметры, так можно, когда есть значение параметра по умолчанию), и как свой (не дефолтный) конструктор (если передать параметр \textbf{max\_size}). В конце мы освобождаем ту память, которую занял объект \textbf{Stack}.
		\end{lecSection}
	\end{lecSection}
	\begin{center}
	Код всего проекта можно смотреть \href{https://github.com/alekseik1/cpp\_lections\_2017/tree/master/lection\%209}{здесь}.
	\end{center}
\end{lecture}
\stepcounter{lectureNo}