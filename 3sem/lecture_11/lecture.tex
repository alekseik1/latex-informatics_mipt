% TODO: ПОМЕНЯЙТЕ НА СВОЙ ПУТЬ ПРИ СБОРКЕ
\renewcommand{\mainFolder}{/home/aleksei/github_projects/latex_works/informatics/3sem}
\renewcommand{\myFolder}{\mainFolder/lecture_\arabic{lectureNo}/}

%	LECTURE INFO
%----------------------------------------------------------------------------------------
\renewcommand{\lectureSubject}{Наследование}
%----------------------------------------------------------------------------------------
%
% Главное - указывать в путях для добавляемых файлов переменную \myFolder.
% Так, новый cpp файл должен иметь путь \cppfile{\myFolder/main}{....} (указывается без расширения)
% Нельзя писать \cppfile{main}{...} !!!
% Если не выполнить это требование, большой проект не будет собираться



\begin{lecture}[\lectureSubject]
	\begin{lecSection}[Пример интерфейса -- UnivMan]
		Представим, что у нас есть некий шаблон, описывающий общую схему кода. Пусть это будет, к примеру, \textit{Unversity Man} -- для краткости будет звать его \textbf{UnivMan}. Им попробуем описать человека из МФТИ. Для нашего интерфейса сделаем некоторые методы: \textbf{getName()}, \textbf{getPhoto()}, \textbf{getDepartment()}. Их тело мы писать \underline{не} будем; эта работа ляжет на конкретную \textit{реализацию} нашего шаблона.
		
		Составим затем реализацию нашего шаблона: пусть, к примеру, мы захотим описать класс учителя вуза --- это класс \textbf{Teacher}. Создав этот класс, мы возьмем на себя обязанность реализовать \underline{все} методы, которые мы прописали в нашем 'шаблоне' \textbf{UnivMan}. При этом мы, помимо прочего, можем и дополнить наш 'дочерний' класс своими методами.
		
	\end{lecSection}
	\begin{lecSection}[Определение наследования]
		Такая иерархия классов подводит нас к третьей парадигме ООП: \textbf{наследованию}. Наследование --- это явление, когда один класс (потомок) перенимает все (строго говоря, почти все; о подробностях см. ниже) поля и методы другого класса (родителя).
		
		\underline{Замечание.} В нашем примере мы затребовали, чтобы класс \textbf{UnivMan} не содержал реализаций никаких функций. Такие классы называются \textit{интерфейсами} -- сами по себе эти штуки бесполезны, но они задают некий шаблон, по которому должны строиться его потомки (в примере это были \textbf{Teacher} и \textbf{Student}).
	\end{lecSection}
	\begin{lecSection}[Иерархия наследования]
		Вопрос о том, какой класс сделать родителем, а какой -- потомком, требует хорошей продуманности.
		
		Если бы мы хотели в нашем примере добавить класс \textit{старосты}, то его следовало бы сделать наследником класса \textit{студентов} и просто добавить специфичные методы (например, функцию раздачи задавальников). \underline{НЕ} стоит делать обычного \textit{студента} наследником \textit{старосты}, равно как и не стоит делать \textit{старосту} прямым наследником \textbf{UnivMan} и потом по-новой реализовывать те же самые методы, что \textit{студент} уже реализовал.
		
		Хорошим правилом для построения схемы наследования дает критерий Барбары Лисков: "Дочерний класс должен удовлетворять всем интерфейсам родительского класса \underline{и} не требовать ничего дополнительного."
	\end{lecSection}
	\begin{lecSection}[Модификаторы доступа]
		Для полей и методов можно разграничить права доступа: кто сможет их видеть, а кто нет. Для этого существует 3 модификатора доступа:
		\begin{enumerate}
			\item \textbf{public} -- доступно любым другим функциям (внутри класса, для потомков и остальных)
			\item \textbf{protected} -- доступно любым наследникам и самому классу.
			\item \textbf{private} -- доступно только самому классу.
		\end{enumerate}
		\cppfile{\myFolder/1}{Демонстрация модификаторов доступа}{1}
		Обратите внимание на строку \textbf{11} -- здесь слово \textbf{public} означает, что класс \textit{наследуется} публично. Другие куски кода будут знать, что \textbf{Derivative} наследует \textbf{Base} и мы сможем через объекты класса \textbf{Derivative} доступаться до всего, что есть в \textbf{Base}. В таком случае тоже можно делать разные модификаторы:
		\begin{enumerate}
			\item \textbf{public} -- все, кто имеет доступ к \textbf{Child} и \textbf{Parent}, будут знать о наследовании.
			\item \textbf{protected} -- только потомок и потомок потомка будут знать о наследовании. Поясним это. Путь наследование происходит по следующей схеме: $\textbf{Parent} \rightarrow \textbf{Child} \rightarrow \textbf{Child-of-child}$. При использовании \textbf{protected} в \textbf{Child} класс \textbf{Child-of-child} и только он будет знать о том, что \textbf{Child} унаследовал \textbf{Parent}. Потомки более высшего порядка и другие классы не будут знать о наследовании.
			\item \textbf{private} -- никто не будет знать о наследовании, кроме самого \textbf{Child}.
		\end{enumerate}
		Подробнее об этом можно прочитать \href{https://stackoverflow.com/questions/860339/difference-between-private-public-and-protected-inheritance}{здесь} (осторожно, английский!).
	\end{lecSection}
	\begin{lecSection}[Override -- переопределение методов]
		В дочернем классе мы можем не просто пользоваться методами родителя, а переопределять их. Это называется \textit{переопределением} метода.
		
		При этом есть и свои тонкости. Рассмотрим их на примере:
		\cppfile{\myFolder/2}{Тонкости вызова переопределенных функций}{2}
		Метод \textbf{foo} (строка \textbf{20}) 'видит' \textbf{x} как объект класса \textbf{Base}. И метод \textbf{b\_pub} он будет \underline{тоже} вызывать из этого класса, даже если мы \textbf{foo} на вход подадим экземпляр класса-наследника.
		
		Заметьте, что функцию мы могли бы и вызывать через обращение к классу как к пространству имен (строка \textbf{23}).
	\end{lecSection}
	\begin{lecSection}[Списки инициализации]
			С конструкторами бывают проблемы. Рассмотрим пример:
			\cppfile{\myFolder/3}{Тонкости конструкторов}{3}
			На строке \textbf{27} конструктор старосты. Ему \underline{нужно} вызвать конструктор родителя. Почему же?
			
			При создании объекта типа \textbf{ElderStudent} мы по факту берем класс \textbf{Student} и обертываем его тем, что мы написали в наследнике. Инициализация класса \textbf{Student} происходит через \textit{конструктор} класса \textbf{Student}. Таким образом, за счет наследования этого класса в \textbf{ElderStudent} мы заставляем программу выполнить конструктор родительского класса (\textbf{Student}). Но вызывать конструктор напрямую нельзя. Конечно, можно понадеяться, что компилятор сделает все тихо и в неявном виде, но что будет, если наш \textit{староста} в конструкторе будет получать не те переменные, что получал в конструкторе обычный \textit{студент}? А если у \textit{студента} нет конструктора по умолчанию, какой же тогда выбрать? Компилятор в этом случае не разберется и единственный способ разрулить ситуацию -- использовать \textit{списки 
				инициализации}. Это сделано после символа ':'.
			
			Магия списка инициализации заключается в том, что значение у нас будет инициализирован \textbf{Student} с параметрами \textbf{x} и \textbf{s} (их мы передали \textit{старосте} в конструктор) еще \underline{до} входа в само тело конструктора. Теперь у нас все хорошо: мы имеем инициализированного студента и уже готовы его отнаследовать и переопределять (что и сделано уже в \textit{теле} конструктора).
			
			Из вышесказанного вытекает \textit{важный вывод}: при создании объекта будут вызваны конструкторы \textbf{всех} родительских классов, начиная от самого старшего в иерархии.
			
			\begin{lecSubsection}{О порядке в списке инициализации}
			\textit{(Т.Ф. не успел этого рассказать на лекции)} При использовании списка инициализации можно инициализировать несколько переменных (а не только \textbf{Student(x, s)}, как у нас в примере). Важно то, что порядок инициализации \underline{не} будет зависеть от \underline{порядка перечисления через запятую} в нашем конструкторе, а будет целиком определяться порядком в \underline{исходном} классе. На нашем примере этого нельзя увидеть, потому что мы инициализируем лишь одну переменную, однако это будет заметно в следующем коде:
			\cppfile{\myFolder/4}{Маленький пример к порядку инициализации}{4}
			\end{lecSubsection}
			Порядок инициализации будет одинаков. Сначала в \textbf{age} уйдет 5, а затем в \textbf{mark} уйдет \textbf{age} (то есть 5). Кстати, в строке \textbf{5} видим еще один способ присвоить переменную \textbf{age} -- \textbf{age(5)}. Для \textbf{age} вызывается конструктор с параметром 5, от этого в \textbf{age} уйдет значение 5 (что логично). (Для тех, кто шарит: на примитивах этот трюк тоже работает. В С++ им для таких целей специально добавили конструктор)
		
	\end{lecSection}
\end{lecture}
\stepcounter{lectureNo}