% TODO: ПОМЕНЯЙТЕ НА СВОЙ ПУТЬ ПРИ СБОРКЕ
\renewcommand{\mainFolder}{/home/aleksei/github_projects/latex_works/informatics}
\renewcommand{\myFolder}{\mainFolder/lecture_\arabic{lectureNo}/}

%	LECTURE INFO
%----------------------------------------------------------------------------------------
\renewcommand{\lectureSubject}{Парадигмы программирования}
%----------------------------------------------------------------------------------------
%
% Главное - указывать в путях для добавляемых файлов переменную \myFolder.
% Так, новый cpp файл должен иметь путь \cppfile{\myFolder/main}{....} (указывается без расширения)
% Нельзя писать \cppfile{main}{...} !!!
% Если не выполнить это требование, большой проект не будет собираться



\begin{lecture}[\lectureSubject]
	\begin{lecSection}[Структурное программирование]
		Структурное программирование строится на следующей идее: разбивать сложную задачу на простые подзадачи. Достигается это путем решения подзадач в функциях. Таким подходом мы уже часто пользовались, но у него есть минус: со временем функций накапливается много и код становится менее читабельным.
		
	\end{lecSection}
	\begin{lecSection}[Модульное программирование]
		В качестве решения указанной проблемы можно функции собрать в отдельные \textit{модули}. Полученная парадигма носит название \textbf{модульного программирования}. Разумеется, при таком подход будет главный модуль -- к примеру, main.cpp. Главный модуль имеет одну особенность: в main.cpp есть функция \textbf{main}, которая содержит вход в программу. Таким образом достигается иерархия модулей.
		
		При построении взаимоотношений модулей очень важно правильно выстроить их зависимости. Нельзя допускать т.н. "межмодульную рекурсию": когда модуль \textbf{module1} инклюдит модуль \textbf{module2}, а модуль \textbf{module2} в то же время инклюдит модуль \textbf{module1}. Использование модулей заставляет думать об их организации.
		
		Стоит понимать, что все парадигмы нужны лишь для удобной воспринимаемости кода, но сами по себе они никак не ускоряют работы программ (а иногда даже могут и замедлить).
	\end{lecSection}
	\begin{lecSection}[Раздельная компиляция]
		Начнем с примера. Напишем структуру для дроби с возможностью использовать комплексные числа.
		%\cppfile{\myFolder/main}{main.cpp}{main1}
		%\cppfile{\myFolder/fractions.hpp}{fractions.hpp}{fractions.hpp}
		%\cppfile{\myFolder/fractions}{fractions.cpp}{fractions.cpp}
		%\cppfile{\myFolder/frac-complex.hpp}{frac\_complex.hpp}{frac\_complex.hpp}
		%\cppfile{\myFolder/frac-complex}{frac\_complex.cpp}{frac\_complex.cpp}
		Будем придерживаться следующей структуры:
		\begin{enumerate}
			\item \textbf{main.cpp} -- единица трансляции (то есть, компилируется). Подключает все хидеры. Собирается в \textbf{main.o}
			\item \textbf{fractions.hpp} -- хидер для \textbf{fractions.cpp}
			\item \textbf{fractions.cpp} -- единица трансляции (то есть, компилируется). Вместе со своим хидером собирается в \textbf{fractions.o}
			\item \textbf{frac\_complex.hpp} -- хидер для \textbf{frac\_complex.cpp}
			\item \textbf{frac\_complex.cpp} -- единица трансляции (то есть, компилируется). Подключает свой хидер \textbf{и} хидер \textbf{fractions.hpp} (потому что мы наверняка будем использовать его функции). При сборке соберется в \textbf{frac\_complex.o}.
		\end{enumerate}
		\begin{center}
			{\large{Код всего проекта можно смотреть \href{https://github.com/alekseik1/cpp_lections_2017/tree/master/lection%208}{здесь}.
				}}
		\end{center}
				
		Помимо прочего, наш проект может иметь несколько \textit{целей}: например, мы захотим собрать готовую программу или же тестовую; подключить файл-тестировщик или нет. Для этого применяется Makefile и система сборки \textbf{make}, однако она не будет обсуждаться в этой лекции. Если вас это заинтересовало, можете поискать в Гугле либо посмотреть исходники лекции, которую в данный момент читаете: она  собрана с использованием \textbf{make}.
		
		\begin{lecSubsection}{Разделяемые (динамические) библиотеки}
			Так называются библиотеки, которые содержатся в ОС. Распространяются в .dll в  ОС Windows или же .so в Linux.
		\end{lecSubsection}
		
		\begin{lecSubsection}{Отступление. Полезный материал на Фоксфорде}
		Подробности по С++ можно найти \href{https://foxford.ru/wiki/informatika/modulnoe-programmirovanie-v-c}{здесь} (материал достаточно ознакомительный, но из него можно вынести много полезного).
		\end{lecSubsection}
	
	\end{lecSection}
	\begin{lecSection}[Условная компиляция]
		Условная компиляция -- компиляция с условиями. Условия компилятору сообщают \textit{директивы} -- команды, обрабатываемые на этапе \textit{препроцессинга}. Часто используемая директива -- это \textbf{\#IFDEF}. Приведем пример ее использования:
		\cppfile{\myFolder/1}{Директива IFDEF}{1}
		Код в \underline{someCode} будет выполнен только тогда, когда был определен \underline{SOMETHING}. Существует похожая директива: \textbf{\#IFNDEF} -- только он срабатывает, если \textit{не} был определен аргументы.
		
		Еще один т.н. "страж включения": \textbf{\#define} \textbf{SOMETHING} -- объявляет \textbf{SOMETHING}. После него \textbf{\#ifdef} уже будет думать, что \textbf{SOMETHING} объявлено.
		
		Все эти штуки используются для того, чтобы не инклюдить один и тот же файл по несколько раз, ведь в таких ситуациях компилятор будет кидать ошибки.
	\end{lecSection}
	
	\begin{lecSection}[Макросы]
		\cppfile{\myFolder/2}{Пример использования макросов}{2}
		Макросы не рекомендуется использовать -- они создают обманчивую привлекательность, однако порождают непредвиденное поведение, поскольку \textbf{не} являются вызовами функции, а всего лишь подставляются препроцессором при текстовой обработке.
	\end{lecSection}
	\begin{lecSection}[extern-переменные]
		Представим себе, что мы хотим создать переменную, которая будет доступна и в том, и другом модуле. Можно ее описать в \textbf{main.cpp}, однако тогда нельзя будет ей пользоваться в тех файлах, которые не подключают \textbf{main.cpp}. 
		
		У нас есть \textbf{fractions.cpp}, которого все подключают. В нее запихнем эту переменную, а в \textbf{fraction.hpp} запишем \textbf{extern int g;}. Это скажет компилятору, что переменная \textbf{g} будет, но стоит ее дожидаться ТОЛЬКО во время компоновки (а не создавать каждый раз при \textbf{include}). То есть, все файлы, которые будут инклюдить \textbf{fractions.hpp}, будут иметь возможность обращаться к переменной \textbf{g}, но при этом сама переменная \textbf{g} будет объявлена \underline{только} в \textbf{fraction.cpp} (и никак не в файлах, которые индклюдят \textbf{fraction.hpp}). Это делает переменную \textbf{g} как глобальной, так и единой для всех файлов --- то, чего мы и добиваемся.
	\end{lecSection}
\end{lecture}
\stepcounter{lectureNo}