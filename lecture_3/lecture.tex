% TODO: ПОМЕНЯЙТЕ НА СВОЙ ПУТЬ ПРИ СБОРКЕ
\renewcommand{\mainFolder}{/home/aleksei/github_projects/latex_works/informatics}
\renewcommand{\myFolder}{\mainFolder/lecture_\arabic{lectureNo}/}

%	LECTURE INFO
%----------------------------------------------------------------------------------------
\renewcommand{\lectureSubject}{Адреса и указатели}
%----------------------------------------------------------------------------------------
%
% Главное - указывать в путях для добавляемых файлов переменную \myFolder.
% Так, новый cpp файл должен иметь путь \cppfile{\myFolder/main}{....} (указывается без расширения)
% Нельзя писать \cppfile{main}{...} !!!
% Если не выполнить это требование, большой проект не будет собираться


\begin{lecture}[\lectureSubject]
	\begin{lecSection}[Доступ к памяти]
		Память, выделяемая программе, неоднородна -- она делится на \textbf{сегменты}. Первый сегмент --- коды программы (режим "только чтение"). Второй -- сегмент DATA -- содержит данные программы. Более того, элементы DATA (к примеру, начальные значения переменных) записывается в .exe файл. Эти данные уходят в оперативку при запуске программы. Переменные, записанные в DATA, называются \textit{статическими}. Помимо этого, для функционирования программы необходима область \textit{стека} --- такой сегмент памяти, который заполнятся снизу вверх и изначально пуст. Когда ОС только загрузилась, в стек выделяется некоторое количество автоматической памяти -- для \textit{локальных переменных}. \\ 
		Память программе выделяется на время ее работы; после ее завершения память высвобождается.
		\cppfile{\myFolder/1}{Пример многократных вызовов функции}{1}
		Рассмотрим, как происходит работа с памятью в примере \ref{1}. Перед вызовом функции в стек программы будет выделено место для хранения "5" (оно в программе будет интерпретировано как n), stack pointer поднимается. stack pointer - это указатель, показывающий на текущее положение стека. Затем, после вызова функции, ее адрес возврата будет записан в стек - stack pointer двинется выше. Потом в стек уйдет "1" (мы же объявили ее). \\
		Попробуем написать функцию, считающую количество рекурсивных вызовов.
		\cppfile{\myFolder/2}{Функция для подсчета количества собственных вызовов}{2}
		Здесь k2 --- глобальная переменная. Ее присваивание происходит в \textit{момент компиляции} программы (т.е. она запишется в .exe и будет переноситься в память в момент загрузки). Функция \textbf{reducer} уменьшает значение k2. \\
		Однако глобальные переменные могут быть опасны! Считается, что нормальная функция не заглядывает в глобальные переменные (в таких случаях функцию называют "чистой", в противном - "грязной").
		\end{lecSection}
		\begin{lecSection}[Модификатор static]
		\cppfile{\myFolder/3}{Та же программа через static}{3}
		Мы переделали программу \ref{2}, теперь переменная k3 не видна в других блоках, но по-прежнему она записывается в сам .exe . Если бы функция была рекурсивной, то была бы такая ситуация, когда переменных k было бы много - на каждом слое рекурсии она создается. Они просто будут записаны в разные ячейки памяти и уйдут после того, как рекурсивный вызов завершится. 
		\cppfile{\myFolder/4}{Подсчет рекурсии}{4}
		В коде выше как раз \textbf{static} делает k одним для всех вызовов рекурсии --- оно при каждом вызове \underline{не} будет присваиваться в ноль. Вместо этого переменная будет увеличиваться на 1, таким образом, мы сможем увидеть глубину рекурсии.
	\end{lecSection}
	\begin{lecSection}[Указатель]
		Указатель - переменная адресного типа.
		\cppfile{\myFolder/5}{Адрес x можно указать}{5}
		Указатели тоже работают только со своими типами: в коде выше нельзя в \textbf{double*} записать число \textbf{int}. Дело в том, что возникнет ложная интерпретация -- ссылка на double превратися в ссылку на int, а поскольку в памяти double и int имеют разные размеры, то можно даже вылезти за пределы своей памяти. Компилятор это запретит, однако все можно обойти:
		\cppfile{\myFolder/6}{Пример обхода заперта}{6}
		У указателей могут тоже быть указатели:
		\cppfile{\myFolder/7}{Указатель на указатель}{7}
		Обратиться к переменной можно несколько способами:
		\cppfile{\myFolder/8}{Разница}{8}
		В последней строке происходит \textit{разыменование} адреса - грубо говоря, считывание данных из того адреса, куда указывает указатель. Разыменовывать надо последовательно:
		\cppfile{\myFolder/9}{Двойное разыменование}{9}
	\end{lecSection}
	\begin{lecSection}[Несколько слов о массивах]
		Массивов в C++ нет. Массив - это константный указатель на область памяти, представляющую содержимое!
		\cppfile{\myFolder/10}{Работа массива}{10}
		Команда объявления массива по факту означает следующее: создать n переменных типа int. \\
		С указателями можно прийти к \textit{адресной арифметике}: так, указатель $p+1$ выше означает, что мы сдвигаемся по памяти от места, куда указывает p, на \textbf{sizeof(1)}. Это иллюстрирует строка 7: A[i] абсолютно равносильна указателю *(A+i). Проверки на i \textit{нет}, то есть, в теории, мы можем убежать вообще в произвольную область памяти.
	\end{lecSection}
	\begin{lecSection}[Динамическая память]
		\cppfile{\myFolder/11}{Пример выделения из дин. памяти}{11}
		Динамическая память не является автоматической, т.е. ей надо явным образом указывать, когда ее выделять, а когда удалять. Если без конца писать вызов get(), то можно постоянно выбивать у системы память и это все приведет к \textit{memory leak} - утечке памяти.
	\end{lecSection}
	\begin{lecSection}[Передача параметров по указателю]
		Передача по параметрам бывает полезна, когда хочется поменять значение переменной внутри самой функции. Функции передается указатель и она, имея ссылку непосредственно на область памяти, может ее менять:
		\cppfile{\myFolder/12}{Передача указателей функции}{12}
		Подробнее -- в следующей лекции.
	\end{lecSection}
\end{lecture}
\stepcounter{lectureNo}