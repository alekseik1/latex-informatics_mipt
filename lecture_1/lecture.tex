% TODO: ПОМЕНЯЙТЕ НА СВОЙ ПУТЬ ПРИ СБОРКЕ
\renewcommand{\mainFolder}{/home/aleksei/github_projects/latex_works/informatics}
\renewcommand{\myFolder}{\mainFolder/lecture_\arabic{lectureNo}/}

%	LECTURE INFO
%----------------------------------------------------------------------------------------
\renewcommand{\lectureSubject}{Z и префикс функция строки}
%----------------------------------------------------------------------------------------
%
% Главное - указывать в путях для добавляемых файлов переменную \myFolder.
% Так, новый cpp файл должен иметь путь \cppfile{\myFolder/main}{....} (указывается без расширения)
% Нельзя писать \cppfile{main}{...} !!!
% Если не выполнить это требование, большой проект не будет собираться


\begin{lecture}[\lectureSubject]
	
	\begin{lecSection}[Z--функция строки]
Z--функция строки --- функция от номера символа.
Z--функция --- это массив длинны \texttt{len(S) = N}, \texttt{z[i]} --- длина совпадающего префикса у строки \texttt{S} и \texttt{S[i:]}.

\texttt{z[0]} не определено. Но мы будем считать, что \texttt{z[0] = 0}. 

\begin{center}
	"a a a a a"\\
	z=[0, 4, 3, 2, 1]\\
	
	"a b a c a b a"\\
	z=[0, 0, 1, 0, 3, 0]
\end{center}

Зачем нужна z--функция?
Будем искать строчку \texttt{p=aba} и все ее вхождения в строке \texttt{abacabadabacaba}. Склеим две строки символом, которого точно нет ни там ни там:
\begin{center}
	\texttt{s = "aba\#abacabadabacaba"}.
\end{center}
Т.к. стоит символ \#, длина искомой подстроки не может быть больше 3.
$$
z = [0, 0, 1, 0, 3, 0, 1, 0, 3, 0, 1, 0, 3, 0, 1, 0, 3, 0, 1]
$$
Там, где \texttt{z[i] == len(p)}, т.е. там, где величина Z--функции равна длине подстроки, у нас есть совпадение, т.е. там подстрока содержится в строке. Позиция вхождения: найдена подстрока в строке, \texttt{pos = i-len(p)-1} --- номер вхождения.

Тривиальное вычисление Z--функции (требует $O(N^2)$).
\pythonfile{\myFolder/1}{Тривиальное вычисление Z-функции}{trivial}
z--блок --- срез строки \texttt{s[i:i+z[i]]}, т.е. это часть строки, совпавшая с подстрокой.

На момент вычисления \texttt{z[i]} существует самый правый отрезок совпадения. Длина этого отрезка равна разнице его правого и левого конца + 1.

\pythonfile{\myFolder/2}{Вычисление за линейное время}{linear}
Этот алгоритм работает за линейное время.
	\end{lecSection}
	\begin{lecSection}[Префикс--функция строки]
		Собственным суффиксом строки называется суффикс, не совпадающий со всей строкой, совпадающий с ее префиксом. 
		
		Префикс--функция строки \texttt{$\pi$[i]} --- массив длинной строки, где \texttt{$\pi$[i]} --- длина наибольшего по длине собственного суффикса подстроки (среза) \texttt{s} начиная от начала и до позиции \texttt{i (s[:i+1])}.
		\begin{center}
			"a a a a a"\\
			pi=[0, 1, 2, 3, 4]\\
			"a b a c a b a"\\
			pi = [0, 0, 1, 0, 1, 2, 3]\\
		\end{center}
		Заметим, что эта функция всегда растет на единицу.
		\pythonfile{\myFolder/3}{Тривиальный алгоритм}{triv1}
		Асимптотика $O(N^3)$.
		\pythonfile{\myFolder/4}{Эффективный алгоритм}{linear1}
	\end{lecSection}
	
	\begin{lecSection}[Алгоритм Кнута — Морриса — Пратта.]
		Эта задача является классическим применением префикс-функции (и, собственно, она и была открыта в связи с этим).
		
		Дан текст t и строка s, требуется найти и вывести позиции всех вхождений строки s в текст t.
		
		Обозначим для удобства через n длину строки s, а через m — длину текста t.
		
		Образуем строку s + \# + t, где символ \# — это разделитель, который не должен нигде более встречаться. Посчитаем для этой строки префикс-функцию. Теперь рассмотрим её значения, кроме первых n+1 (которые, как видно, относятся к строке s и разделителю). По определению, значение $\pi$[i] показывает наидлиннейшую длину подстроки, оканчивающейся в позиции i и совпадающего с префиксом. Но в нашем случае это $\pi$[i] — фактически длина наибольшего блока совпадения со строкой s и оканчивающегося в позиции i. Больше, чем n, эта длина быть не может — за счёт разделителя. А вот равенство $\pi$[i] = n (там, где оно достигается), означает, что в позиции i оканчивается искомое вхождение строки s (только не надо забывать, что все позиции отсчитываются в склеенной строке s+\#+t).
		
		Таким образом, если в какой-то позиции i оказалось $\pi$[i] = n, то в позиции i - (n + 1) - n + 1 = i - 2 n строки t начинается очередное вхождение строки s в строку t.
		
		Как уже упоминалось при описании алгоритма вычисления префикс-функции, если известно, что значения префикс-функции не будут превышать некоторой величины, то достаточно хранить не всю строку и префикс-функцию, а только её начало. В нашем случае это означает, что нужно хранить в памяти лишь строку s + \# и значение префикс-функции на ней, а потом уже считывать по одному символу строку t и пересчитывать текущее значение префикс-функции.
		
		Итак, алгоритм Кнута-Морриса-Пратта решает эту задачу за O(n+m) времени и O(n) памяти.
		
		Подробнее материал лекции изложен на \href{http://e-maxx.ru/algo/prefix_function}{сайте}.
	\end{lecSection}
\end{lecture}
\stepcounter{lectureNo}