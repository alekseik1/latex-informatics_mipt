% TODO: ПОМЕНЯЙТЕ НА СВОЙ ПУТЬ ПРИ СБОРКЕ
\renewcommand{\mainFolder}{/home/aleksei/github_projects/latex_works/informatics}
\renewcommand{\myFolder}{\mainFolder/lecture_\arabic{lectureNo}/}

%	LECTURE INFO
%----------------------------------------------------------------------------------------
\renewcommand{\lectureSubject}{Динамическая память. Продолжение.}
%----------------------------------------------------------------------------------------
%
% Главное - указывать в путях для добавляемых файлов переменную \myFolder.
% Так, новый cpp файл должен иметь путь \cppfile{\myFolder/main}{....} (указывается без расширения)
% Нельзя писать \cppfile{main}{...} !!!
% Если не выполнить это требование, большой проект не будет собираться


\begin{lecture}[\lectureSubject]
	\begin{lecSection}[Динамические массивы]
		Как было сказано, массивов в C++ нет. Повторим объявление указателей: \\
		\cppfile{\myFolder/1}{Пример объявления указателей}{1}
		В строке \textbf{4} мы получаем указатель на \textbf{A[5]}. В строке \textbf{8} мы создаем число, да и еще присваиваем ему значение.
		\cppfile{\myFolder/2}{Объявление массива через \textbf{new}}{2}
		При объявлении массива через \textbf{new} нужно обязательно его удалять через \textbf{delete[]} -- оператор удаления.
	\end{lecSection}
	\begin{lecSection}[Структуры в C++]
		В C++ существует такая вещь, как структура -- набор переменных под одной крышей.
		\cppfile{\myFolder/ex1}{Простейшая структура}{ex1}
		Обратите внимание на строки \textbf{23} и \textbf{25}: такое сокращение еще часто будет встречаться (для указателей вместо "." используется "$->$"). Метод для распечатки мы вынесли отдельно для удобства. \\
		Подход к распечатке в самой первой функции имеет минус: при вызове функции мы создаем локальную копию Student. Метод \textbf{studentPrint1} лишен этого -- там передается по ссылке. Но возникает проблема, ведь мы внутри функции случайно можем изменить переменную x и этот результат будет виден извне. Решение дает передача по константной ссылке, что сделано в \textbf{studentPrint2}.\\ Существует еще одно решение задачи, в котором мы сначала создаем объект Student в памяти, получаем на него указатель, а затем через него меняем свойства объекта:
		\cppfile{\myFolder/ex2}{Еще одно решение со структурой}{ex2}
		Из структур можно составлять массивы, что неудивительно, учитывая, что массив - это просто несколько переменных. В качестве примера можно привести следующий код: \newpage
		\cppfile{\myFolder/ex3}{Массив из структур}{ex3}
	\end{lecSection}
	\begin{lecSection}[Массивы и функции]
		В функциях можно менять массивы, но их нельзя возвращать. Код внизу -- пример изменения массива внутри функции. \newpage
		\cppfile{\myFolder/ex4}{Изменение массива внутри функции}{ex4}
	\end{lecSection}
	\begin{lecSection}[Двумерный массив и передача его функции] 
		Двумерные массивы работают так же, как в Питоне. Тем не менее, у них есть некоторые особенности, связанные с их способом представления в памяти (помним, что массив по факту лишь набор переменных). Одна из этих особенностей видна в коде ниже, где мы передаем двумерный массив в функцию:
		\cppfile{\myFolder/ex5}{Передача массива в функцию}{ex5}
		Обратите внимание: в объявлении функции \textbf{printer} мы обязательно указываем длину (вторая квадратная скобка).
	\end{lecSection}
	\begin{lecSection}[Статические массивы]
		\cppfile{\myFolder/ex6}{Указание на элемент массива}{ex6}
		В коде выше видно, что для прохождения по элементам массива в функции  необходимо заранее знать его длину. Если посмотреть на выражение \ref{ex6}, то станет видно, что эта длина уходит в инструкции прохода по массиву еще на этапе компиляции, поэтому ее и нужно было передавать заранее, как это сделано в \ref{ex5}. Но можно ли сделать функцию \textbf{printer} без явного указания длины массива? Ответ дают динамические массивы.
	\end{lecSection}
	\begin{lecSection}[Динамические массивы]
		Динамические массивы --- это массивы, хранящиеся в так называемой динамической памяти (\textit{heap}). Динамические массивы объявлять несколько сложнее: так, для двумерного случая необходимо делать указатель на область памяти с указателями, каждый указатель в которой, в свою очередь, будет указывать на область памяти с нашими объектами (к примеру, \textbf{int}). Звучит не очень, однако пример \ref{ex8} может немного прояснить этот момент.
		\cppfile{\myFolder/ex7}{Объявление динамического массива}{ex7}
		\textbf{А} -- это массив из указателей типа \textbf{double*}. Каждый элемент этого массива - массив размера \textbf{width}. Таким образом, \textbf{А} есть двумерный массив. Обращение к его элементам происходит так же, как и при обычном объявлении массива, что видно в строке \textbf{26}.
		Мы сделали массив, распечатали его, а затем удалили, чтобы освободить память. При этом следует помнить такой трюк:
		\cppfile{\myFolder/ex8}{Порядок разыменования}{ex8}
	\end{lecSection}
		\begin{center}
			{Исходные коды всех программ можно найти \href{https://github.com/alekseik1/cpp\_lections\_2017/tree/master/lection\%204}{здесь}}
		\end{center}
\end{lecture}
\stepcounter{lectureNo}