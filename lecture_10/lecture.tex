% TODO: ПОМЕНЯЙТЕ НА СВОЙ ПУТЬ ПРИ СБОРКЕ
\renewcommand{\mainFolder}{/home/aleksei/github_projects/latex_works/informatics}
\renewcommand{\myFolder}{\mainFolder/lecture_\arabic{lectureNo}/}

%	LECTURE INFO
%----------------------------------------------------------------------------------------
\renewcommand{\lectureSubject}{Инкапсуляция}
%----------------------------------------------------------------------------------------
%
% Главное - указывать в путях для добавляемых файлов переменную \myFolder.
% Так, новый cpp файл должен иметь путь \cppfile{\myFolder/main}{....} (указывается без расширения)
% Нельзя писать \cppfile{main}{...} !!!
% Если не выполнить это требование, большой проект не будет собираться



\begin{lecture}[\lectureSubject]
	\begin{lecSection}[Понятие инкапсуляции]
		В Питоне инкапсуляции не было. Когда мы делаем структуру, мы полагаем, что пользователь будет взаимодействовать с ней через те методы, что мы пропишем. Однако это может нарушиться. Для того, чтобы предотвратить такую ситуацию, существует \textit{инкапсуляция}. Инкапсуляция создает ограничения для программиста, тем самым организуя \textit{логику} нашего кода.
		\cppfile{\myFolder/1}{Инкапсуляция на примере класса Student}{1}
		В коде выше класс делится на две секции: \textbf{private} и \textbf{public}. То, что находится в секции \textbf{private}, \underline{не} будет видно снаружи класса. Эти секции могут следовать друг за другом в любом порядке и любом количестве(т.е., мы можем сначала описать публичную, потом приватную, затем опять публичную), но обычно их пишут один раз, объявляя сразу все, что нужно.
		
		Общий принцип инкапсуляции заключается в следующем: все атрибуты класса надо "прятать".
		
		При принятии решения, в какую из секций пихнуть свой метод, следует помнить, что \textit{конструкторы} класса \textbf{должны} быть публичными.
		
		\underline{Доп. инфа от ТФ.} Иногда может возникнуть необходимость разрешить создавать экземпляры класса, но не копировать их. В таких случаях конструктор класса следует сделать публичным, а конструктор клонирования положить в приватную секцию.
		\end{lecSection}
		
		\begin{lecSection}[Геттеры и сеттеры]
		
		При сокрытии полей стандартом обращения к ним служат \textit{геттеры} (getters) и \textit{сеттеры} (setters) -- методы, соответственно возвращающие и изменяющие поле. В нашем примере \ref{1} они объявлены на \textbf{13} и \textbf{18} строках.
		
		 Геттеры и сеттеры имеют интересную фишку: они не обязаны работать с существующим полем класса. Вполне возможно, что они будут задавать/возвращать другие величины, но пользователь будет думать, что они содержатся в классе. Так можно создавать удобные абстракции.
		
		\end{lecSection}
		
		\begin{lecSection}[Модификатор \textbf{const} после функции]
			В примере \ref{1} на строчке \textbf{25} мы видим модификатор \textbf{const} \textit{после} объявления метода. Это говорит компилятору, что метод не будет менять никаких полей класса в ходе своей работы. Стоит учесть, что если мы будем пользоваться константной ссылкой на экземпляр класса, то в ней мы сможем вызывать только константные методы (чтоб компилятор был уверен, что мы не изменим константный объект).
		\end{lecSection}
		
		\begin{lecSection}[Модификатор \textbf{static}]
			\begin{lecSubsection}{Статические поля}
				Иногда бывает необходимым сделать поле класса универсальным (т.е. единым) для всех его экземпляров. В таком случае используется модификатор \textbf{static}. Рассмотрим пример:
				\cppfile{\myFolder/2}{Простой пример статического поля}{2}
				Здесь мы при создании нового экземпляра класса увеличиваем \textbf{count} на 1, а при удалении -- уменьшаем. Важно отметить, что переменная \textbf{count} существует всегда, даже если не было создано ни одного объекта данного класса.
			\end{lecSubsection}
			\begin{lecSubsection}{Статические методы}
				Однако у такого подхода есть проблема: чтобы получить это поле через какой-либо метод класса, нам необходимо будет создать объект. Решает это, как можно догадаться, \textit{статический метод} (строка \textbf{12}). Такой метод привязан к классу, но никак не к объекту класса. Это несет свои минусы: статический метод не может в своем коде обращаться к нестатическим методам и полям (они ведь уже зависят от объекта, а статический метод от этого избавляется). Более того, в статическом методе \underline{не} определен \textbf{this} -- указатель на экземпляр класса.
			\end{lecSubsection}
			
			\begin{lecSubsection}{Пространство имен}
				В коде мы использовали (строка \textbf{32}) \textbf{SelfCounter} как \textit{пространство имен}. Каждый класс создает свое пространство имен, в котором находятся его поля и методы (разумеется, те, что в публичной секции). Таким способом удобно обращаться к статическим полям и методам.
			\end{lecSubsection}
		\end{lecSection}
		
		\begin{lecSection}[Дружественные функции]
			Бывает, что определенному классу \textbf{2} требуется добраться до атрибутов другого класса (класса \textbf{1}) (как это могут делать его экземпляры), но при этом сами классы никак не связаны. Для этого придется немного ослабить \textit{инкапсуляцию} и объявить в классе \textbf{1} (откуда хотим брать) требуемые \underline{дружественные} функции или даже классы. Затем дружественные функции или классы достаточно объявить где-нибудь снаружи -- и они уже будут иметь доступ внутрь \textbf{1}. Более того, можно сделать функцию дружественной даже в том случае, если она не была еще объявлена (предполагая, что это будет сделано позднее). При этом дружественные функции \textbf{не} являются методами класса \textbf{1} (того, куда мы открываем доступ).
			
			Иллюстрацией этому может служить следующий пример:
			\newpage
			\cppfile{\myFolder/3}{Пример дружественных функций}{3}
			В строке \textbf{1} мы объявляем класс \textbf{CarMaster}, но описываем его позже. Зачем?
			
			Если не объявить заранее CarMaster, то строка \textbf{8} будет вызывать ошибку, так как мы попытаемся обратиться к необъявленному классу. А объявить класс \textbf{CarMaster} перед \textbf{Car} мы не можем, так как в этом случае он будет обращаться к полю еще не объявленного класса \textbf{Car}. Решение этого -- описать сигнатуру класса \textbf{CarMaster} перед классом \textbf{Car}, но \textit{описать} ее позднее. Такой трюк мы будем часто использовать в будущем.
		\end{lecSection}
\end{lecture}
\stepcounter{lectureNo}