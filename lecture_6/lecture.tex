% TODO: ПОМЕНЯЙТЕ НА СВОЙ ПУТЬ ПРИ СБОРКЕ
\renewcommand{\mainFolder}{/home/aleksei/github_projects/latex_works/informatics}
\renewcommand{\myFolder}{\mainFolder/lecture_\arabic{lectureNo}/}

%	LECTURE INFO
%----------------------------------------------------------------------------------------
\renewcommand{\lectureSubject}{Продвинутая работа с функциями}
%----------------------------------------------------------------------------------------
%
% Главное - указывать в путях для добавляемых файлов переменную \myFolder.
% Так, новый cpp файл должен иметь путь \cppfile{\myFolder/main}{....} (указывается без расширения)
% Нельзя писать \cppfile{main}{...} !!!
% Если не выполнить это требование, большой проект не будет собираться



\begin{lecture}[\lectureSubject]
	\begin{lecSection}[Перегрузка (overload) функций]
		Полиморфизм --- много разных функций с одним именем. При вызове будет выбираться только одна: та, которая лучше всего подходит по входным параметрам. Это означает, что у функции один \textit{интерфейс} и много \textit{реализаций}. Рассмотрим пример:
		\cppfile{\myFolder/1}{Пример полиморфизма}{1}
		В примере \ref{1} мы пишем одну функцию \textbf{absolute} три раза: по одному на каждый тип входного (и, соответственно, возвращаемого) объекта. В случае, когда для заданного типа данных нет подходящей функции, C++ отбирает несколько функций как кандидатов на вызов, а затем выбирает их в следующем порядке:
		\begin{enumerate}
			\label{cand}
			\item Точное совпадение типов, если оно есть.
			\item Приведение путем повышения разрядности числа и вызов кандидата с полученным типом (например, \textbf{int8} $\rightarrow$ \textbf{int16})
			\item Стандартное приведение типов (например, \textbf{float} $\rightarrow$ \textbf{int}). Оно уже менее надежно, поэтому и находится ниже по приоритету.
			\item Пользовательское приведение типов, т.е. приведение к типу, объявленному пользователем (программистом, написавшим тип).
			\item Эллипсис. В C++ существуют функции, у которых на вход поступает неопределенное число параметров -- они называются эллипсис.
			\cppfile{\myFolder/2}{Пример эллипсиса}{2}
		\end{enumerate}
		Если на какой-то стадии проверки будет несколько кандидатов, равноправно удовлетворяющих условиям, то компилятор выдаст ошибку (он не поймет, какую вызывать).
	\end{lecSection}
	\begin{lecSection}[Шаблоны]
		Хотелось бы, чтобы можно было делать функцию с неопределенным типом, как здесь: \newpage
		\cppfile{\myFolder/3}{Неопределенный тип}{3}
		Однако C++ не позволит этого сделать. Дело в том, что при компиляции подобного кода необходимо под каждый тип переменной, для которой вызывается функция, иметь функцию в соответствии с \textit{шаблоном}. Исправим код:
		\cppfile{\myFolder/4}{Неопределенный тип с шаблоном}{4}
		Тут может возникнуть проблема. Если бы мы вызвали \textbf{absolute} от строки, то во время компиляции, при \textit{инстанцировании} функции для типа \textbf{string}, возникнет ошибка -- у \textbf{string} нет оператора унарного минуса (т.е. нельзя для строки s делать операцию `-s`). Эту проблему можно решить, если явно указать, каким типом инстанцировать функцию:
		\cppfile{\myFolder/5}{Явное инстанцирование функции}{5}
		Здесь мы изменили вызов на \textbf{absolute<int32\_t>}, тем самым указав тип, которым будет инстанцирована функция при компиляции.
		
		Посмотрим, как ведет себя шаблон:
		\cppfile{\myFolder/6}{Сложное инстанцирование}{6}
		В коде функция \textbf{self\_counter<1>} будет вызвана 3 раза, а \textbf{self\_counter<2>} -- только 2. Дело в том, что мы функцию инстанцируем по-разному: сначала с 1, потом с 2 (как будто это разные функции). Простой код \textbf{self\_counter()} в этом случае уже не работает, так как для инстанцирования есть несколько подходящих кандидатов (см. \ref{cand}).
		\cppfile{\myFolder/7}{Инстанцирование с параметром по умолчанию}{7}.
		Пример выше может не работать, Т.Ф. обещает рассказать об этом через несколько лекций.
	\end{lecSection}
	\begin{lecSection}[Аргументы функции по умолчанию]
		В С++ можно создавать функции, у которых будут значения по умолчанию:
		
		\cppfile{\myFolder/8}{Функция с параметрами по умолчанию}{8}
		Единственная тонкость: значение по умолчанию пишется в \textit{реализации} функции, а не в ее объявлении.
	\end{lecSection}
	\begin{lecSection}[Односвязный список для любого типа данных]
		Теперь мы можем переписать \textbf{LinkedList} из прошлой лекции:
		\cppfile{\myFolder/linkedList}{LinkedList}{9}
		Эту реализацию LinkedList можно несколько усложнить, разделив на файлы: один будет хранить лишь LinkedList, а другой будем пользоваться готовым кодом из первого. Получится что-то вроде библиотеки для Linked List. Часть ее реализации представлена ниже. Код далее достаточно сложен, и многие его аспекты будут объяснены в следующих лекциях.
		\cppfile{\myFolder/linkedListMain}{Основная часть}{10}
		\cppfile{\myFolder/linkedListHeader}{Хидер}{11}
		\begin{center}
			{Исходные коды всех программ можно найти \href{https://github.com/alekseik1/cpp\_lections\_2017/tree/master/lection\%206}{здесь}}
		\end{center}
	\end{lecSection}
\end{lecture}
\stepcounter{lectureNo}