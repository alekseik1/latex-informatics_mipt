% TODO: ПОМЕНЯЙТЕ НА СВОЙ ПУТЬ ПРИ СБОРКЕ
\renewcommand{\mainFolder}{/home/aleksei/github_projects/latex_works/informatics}
\renewcommand{\myFolder}{\mainFolder/lecture_\arabic{lectureNo}/}

%	LECTURE INFO
%----------------------------------------------------------------------------------------
\renewcommand{\lectureSubject}{Строки и файлы в C++}
%----------------------------------------------------------------------------------------
%
% Главное - указывать в путях для добавляемых файлов переменную \myFolder.
% Так, новый cpp файл должен иметь путь \cppfile{\myFolder/main}{....} (указывается без расширения)
% Нельзя писать \cppfile{main}{...} !!!
% Если не выполнить это требование, большой проект не будет собираться


\begin{lecture}[\lectureSubject]
	\begin{lecSection}[Хранение строк]
		Строки делятся на \textit{C-строки} и \textit{ANSI-строки}. В разных языках строки реализованы по-разному. Так, в Pascal они хранятся как \textit{ANSI-строки}: в первой ячейке памяти записана длина строки, а затем последовательно идут символы строки. Главный минус такого подхода --- ограниченность длины строки (255 символов). Этот недостаток отсутствует в \textit{C-строках}.
		
		В \textit{С-строках} используется следующая схема хранения: в памяти просто идет последовательность символов и завершается \textbf{нулем} (типа \textbf{int}, не "0"). Так, строка "Hello"\, будет записана как последовательность 'H', 'e', 'l', 'l', 'o', 0x0 (строки такого типа называются \textit{zero-ending string}). НО! Если мы сделаем обращение и изменим какой-либо символ на 0 (типа целочисленное), то строка поделится на две, ведь теперь у нее два символа окончания. Это --- один из минусов такого подхода.
	\end{lecSection}
	\begin{lecSection}[Операции со строками]
		Конкатенация строки можно делать с помощью стандартной библиотеки \textbf{cstring}.
		\cppfile{\myFolder/1}{Работа со строками}{1}
		В этом коде мы считываем строки, а затем их конкатенируем. Но Т.Ф. не любит эту библиотеку. Дело в том, что \textbf{strcat} сначала проходит и за линейное время находит ноль в конце строки, дабы узнать, где ее конец, а затем уже объединяет обе. Если такой код засунуть в цикл, то (из свойств арифметической прогрессии) мы подарим нашему коду квадратичную асимптотику.
		
		В MacOS сделано несколько интереснее: используется как число, равное длине строки, в ее начале, так и символ окончания в конце (комбинированный подход).
		
		При работе со строками следует быть осторожными: при операции \fbox{+=} можно уйти за аллоцированную (выделенную) память для данной строки и стереть ее содержимое. Кстати, в С++ строка --- это объект. Для нас сейчас это значит, что операции, которые нам кажутся простыми (наподобие \fbox{+=}), на деле такими не являются --- они реализованы по уму. К тому же, у строк есть свои методы и поля. К примеру, метод \textbf{s.size()} вернет длину строки за $O(1)$. У строк автоматическая работа с памяти --- язык автоматически выделяет столько памяти, сколько нужно.
		
		Т.Ф. рекомендует пользоваться C++ -- строками вместо С--строк.
	\end{lecSection}
	\begin{lecSection}[C++\, -- строки]
		В C++ строки входят в окружение \textbf{std}.
		\cppfile{\myFolder/2}{Объявление строки в С++}{2}
		В Python строки кодируются стандартом \underline{UTF-8}. В таком подходе память используется в разных количествах для разных символов, поэтому при вставке символа в середину строки возникают проблемы переноса (одна из причин, почему в Python строки неизменяемы). C++ лишен такого недостатка и здесь строку можно менять посимвольно.
		
		C++ не разделяет типы символа и \textit{кода} символа. Символ = код символа. Вообще, подробности можно изучить \href{http://cplusplus.com}{здесь}.
	\end{lecSection}
	
	\begin{lecSection}[Считывание строки]
		Существует несколько способов читать строки:
		\cppfile{\myFolder/3}{Считывание строки}{3}
		Обратите внимание: \textbf{cin $\gg$ s} возвращает \textbf{true} или \textbf{false}, в зависимости от того, закончился ли ввод.
		
		Другой способ заключался в методе \textbf{getline}, которому на вход поступает поток ввода (см. ниже) и строка s, куда будет записано. Различие следующее: \textbf{cin} читает до символа пробела, тогда как \textbf{getline} читает до символа переноса строки.
	\end{lecSection}
	\begin{lecSection}[Файловые потоки]
		Стандартная библиотека для работы с потоками --- это \textbf{fstream}. Она дает три потока для работы: \textbf{ifstream} для ввода и \textbf{ofstream} для вывода и \textbf{fstrim} для обоих вариантов.
		\cppfile{\myFolder/4}{Пример работы с потоками}{4}
		В коде выше было бы неплохо закрыть файл после окончания работы с ним. Более того, операционная система может дать отказ, если мы затребуем открытие слишком большого количества файлов. Однако C++ умный, он закроет файл после окончания существование объекта (в ходе выполнения деструктора, о них будет сказано в следующих лекциях).
		
		Во время открытия потока можно указать для него \textit{режим}: только для чтения и т.п.
		\cppfile{\myFolder/5}{Режимы потока}{5}
		Подробнее о режимах можно почитать в документации.
	\end{lecSection}	
	\begin{lecSection}[Строковые потоки]
		Работа со строковыми потоками тоже проходит через стандартную библиотеку:
		\cppfile{\myFolder/6}{Строковые потоки}{6}
	\end{lecSection}
	\begin{lecSection}[Односвязный список]
		Попробуем сделать односвязный список в C++ по аналогии с тем, что мы делали в Python.
		\cppfile{\myFolder/7}{Реализация односвязного списка}{7}
		\begin{enumerate}
			\item 		\textbf{typedef} --- это создание синонима типа \textbf{string}. Это сделано только для того, чтобы не писать каждый раз \textbf{std::string}, другого назначения у такой конструкции для нас нет.
			\item \textbf{struct tNode} --- объявление структуры ноды. В ней всего две переменные: свое значение и ссылка на следующую ноду.
			\item \textbf{tNode * \dots} --- сигнатура функции \textit{insert}\_\textit{node}. Ее мы опишем позже.
			\item В методе \textbf{main} мы создаем ноду через \textbf{new}, затем сохраняем ссылку на созданный объект. После этого мы записываем туда какую-то информацию ("Hello" в примере), далее прикрепляем к ней другие ноды.
			\item В цикле мы прогуливаемся по всем нодам и выводим их содержимое. Обратите внимание на переход к следующей ноде в последней строке цикла.
			\item Функция \textbf{insert\_node} --- изюминка нашего кода. Ей передается указатель на нашу ноду. Внутри функции мы создаем новую ноду, заполняем в нее данные из \textbf{data}, а в качестве следующей ноды записываем ту, что мы передали функции. Из этого получается, что мы добавляем ноды в обратном порядке, так как только что созданная нода встает впереди старой.
		\end{enumerate}
	\end{lecSection}
			\begin{center}
				{Исходные коды всех программ можно найти \href{https://github.com/alekseik1/cpp\_lections\_2017/tree/master/lection\%205}{здесь}}
			\end{center}
\end{lecture}
\stepcounter{lectureNo}